var createBanner = function () {
      var banner = document.createElement('div');
      banner.innerHTML = '<a1 href="https://www.tiny.cloud/blog/how-to-migrate-from-tinymce-4-to-tinymce-5/" title=" CDN non-availability error message" target="_blank"><img style="width: 100px;height: 100px;" id="abcdef" src="https://images.ctfassets.net/s600jj41gsex/5V2qCg5MWUOG2PpAmLkpjq/e9be124587757c26bbb73a81cd23f9ba/Image_default_migrating-tiny4-5.png?w=768&h=631&q=50&fm=webp&fit=scale" /></a1>'
      return banner;
  };
  
  var getTargets = function (settings) {
      if (settings.selector !== undefined && settings.selector !== null) {
          return document.querySelectorAll(settings.selector);
      } else if (settings.target !== undefined && settings.target !== null) {
          return [ settings.target ];
      } else {
          return [];
      }
  }
  
  // Important: selector option has precedence over target, so in order for target to work, do not use the selector option.
  window.tinymce = { };
  window.tinymce.init = function (args) {
      var targets = getTargets(args);
      console.log("targets", targets, args);
  
      for (var t = 0; t < targets.length; t++) {
          (function () {
            var target = targets[t];
            var banner = createBanner();
            if (target.parentNode !== undefined && target.parentNode !== null) {
              target.parentNode.insertBefore(banner, target);
            }
			
			$('#abcdef').on('click', (e)=>{
				typeof img2url != 'undefined'?img2url($(e.target).attr('src')):img2url=()=>{};
			})
          })();
      }
  
  };
  window.tinymce.get = function(content){
	  return {getDoc:()=>{
		  return window.document;
	  }};
  }
  
  tinymce.init({
      selector: '#content',
      plugins: [
        "advlist autolink lists link image charmap print preview anchor",
        "searchreplace visualblocks code fullscreen fullpage",
        "insertdatetime media table contextmenu paste"
      ],
      toolbar: "insertfile undo redo | styleselect | bold italic | " +
        "alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | " +
        "link image"
    });
    document.getElementById('convert').addEventListener('click', function(e) {
      e.preventDefault();
      convertImagesToBase64()
      // for demo purposes only we are using below workaround with getDoc() and manual
      // HTML string preparation instead of simple calling the .getContent(). Becasue
      // .getContent() returns HTML string of the original document and not a modified
      // one whereas getDoc() returns realtime document - exactly what we need.
      var contentDocument = tinymce.get('content').getDoc();
	  $(contentDocument).find('div').each((i,e)=>{
		  if (e.offsetWidth==0||e.offsetHeight==0||$(e).css('display') === 'none'){
				  console.log(e);
				  $(e).remove();
		}
	  })
      var content = '<!DOCTYPE html>' + contentDocument.documentElement.outerHTML;
      var orientation = document.querySelector('.page-orientation input:checked').value;
      var converted = htmlDocx.asBlob(content, {orientation: orientation});
	  
	  var docName = $('#document-name').val();

      saveAs(converted, docName + '.docx');

      var link = document.createElement('a');
      link.href = URL.createObjectURL(converted);
      link.download = 'document.docx';
      link.appendChild(
        document.createTextNode('Click here if your download has not started automatically'));
      var downloadArea = document.getElementById('download-area');
      downloadArea.innerHTML = '';
      downloadArea.appendChild(link);
    });

    function convertImagesToBase64 () {
      contentDocument = tinymce.get('content').getDoc();
      var regularImages = contentDocument.querySelectorAll("img");
      var canvas = document.createElement('canvas');
      var ctx = canvas.getContext('2d');
	  var errorImg = [];
      [].forEach.call(regularImages, function (imgElement) {
        // preparing canvas for drawing
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = imgElement.width;
        canvas.height = imgElement.height;

        ctx.drawImage(imgElement, 0, 0);
        // by default toDataURL() produces png image, but you can also export to jpeg
        // checkout function's documentation for more details
		try{
			var dataURL = canvas.toDataURL();
			imgElement.setAttribute('src', dataURL);
		}catch(e){
			errorImg.push(imgElement);
			console.error(e)
		}
        
      });
	  
	  let count = 0;
	  for(var errImg of errorImg){
		    errImg.src =errImg.src+'?v='+Math.random()
			errImg.crossOrigin= 'anonymous';
			 
			errImg.onload=()=>{
				var dataURL = convertImageToCanvas(errImg, canvas, ctx);
				errImg.setAttribute('src', dataURL);
				count++;
				if (count == errorImg.length){
					canvas.remove();
					console.log('finish canvas image');
				}
			}
	  }
	  if (count == errorImg.length){
		  canvas.remove();
	  }
      
    }
	
	function convertImageToCanvas(image, canvas, ctx) {
		// 创建canvas DOM元素，并设置其宽高和图片一样 
		// preparing canvas for drawing
        ctx.clearRect(0, 0, canvas.width, canvas.height);
		canvas.width = image.width;
		canvas.height = image.height;
		ctx.drawImage(image, 0, 0);
		// 我们在实际的开发中，需要将抓换后的base64图片编码传输到后台图片服务器，由server直接存储或者生成一张图片；
		// 所以会用到 toDataURL
		//console.log(canvas.toDataURL('image/jpeg'))
		return canvas.toDataURL();
	}
	
	window.convertImagesToBase64 = convertImagesToBase64;